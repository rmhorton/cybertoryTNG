<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DNA Melting – Reference vs Simulation Tuner</title>
  <style>
    :root {
      --bg: #0f172a; --panel: #111827; --muted: #9ca3af; --text: #e5e7eb; --accent: #38bdf8; --ok:#22c55e; --warn:#f97316; --err:#ef4444;
    }
    html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
    .wrap{max-width:1200px;margin:20px auto;padding:0 16px}
    h1{margin:6px 0 2px;font-size:28px}
    .sub{color:var(--muted);margin-bottom:18px}
    .grid{display:grid;grid-template-columns:380px 1fr;gap:18px}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));border:1px solid rgba(255,255,255,.08);border-radius:16px}
    .hd{padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.06);font-weight:700;color:#cbd5e1}
    .bd{padding:12px 14px}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 2px 6px}
    select,input{width:100%;background:#0b1220;border:1px solid rgba(255,255,255,.1);color:var(--text);border-radius:12px;padding:9px 10px;font-size:14px}
    .row2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px}
    .param-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:10px}
    .param-field{display:flex;flex-direction:column}
    .pill{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:12px;font-size:13px}
    .stats{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin-top:8px}
    .btn{cursor:pointer;display:inline-block;border:1px solid rgba(255,255,255,.12);background:linear-gradient(180deg,rgba(56,189,248,.25),rgba(56,189,248,.15));color:white;border-radius:12px;padding:9px 12px;font-weight:700}
    .btn.secondary{background:linear-gradient(180deg,rgba(167,139,250,.2),rgba(167,139,250,.1))}
    .note{font-size:12px;color:var(--muted)}
    .err{color:#fecaca;background:rgba(239,68,68,.1);border:1px solid rgba(239,68,68,.3);padding:8px 10px;border-radius:10px;display:none}
    canvas{width:100%;height:360px;background:#0b1220;border-radius:12px;border:1px solid rgba(255,255,255,.08);}
    .legend{display:flex;gap:12px;margin:8px 0}
    .lg{display:flex;align-items:center;gap:6px}
    .dot{width:10px;height:10px;border-radius:50%}
    .hr{height:1px;background:rgba(255,255,255,.08);margin:12px 0}
    .rowEnd{display:flex;gap:10px;align-items:center;justify-content:flex-start;margin-top:8px}
  </style>
</head>
<body>
<div class="wrap">
  <h1>DNA Melting – Reference vs Simulation Tuner</h1>
  <div class="sub">Load an experimental reference curve, pick a simulation algorithm from <code>meltingLib.js</code>, and tune parameters to match. Override the temperature axis to compare on a common grid.</div>
  
  <div class="grid">
    <!-- Controls -->
    <div class="card">
      <div class="hd">Reference & Inputs</div>
      <div class="bd">
        <label>Reference dataset</label>
        <select id="refSelect"></select>
        <div class="note" id="seqMeta">—</div>
        <div class="row2">
          <div>
            <label>[Na⁺] (M)</label>
            <input id="Na" type="number" value="0.05" step="0.001" />
          </div>
          <div>
            <label>[Mg²⁺] (M)</label>
            <input id="Mg" type="number" value="0.001" step="0.0001" />
          </div>
        </div>
        <div class="hr"></div>
        <label>Simulation algorithm</label>
        <select id="algo"></select>
        <div id="paramControls" class="param-grid"></div>

        <div class="row2" style="margin-top:8px;align-items:end">
          <div>
            <label>Override temperature range (°C)</label>
            <div class="row2">
              <input id="tmin" type="number" value="40" step="0.1" />
              <input id="tmax" type="number" value="100" step="0.1" />
            </div>
          </div>
          <div>
            <label>Resolution (ΔT, °C)</label>
            <input id="tstep" type="number" value="0.1" step="0.1" min="0.01" />
          </div>
        </div>

        <div class="rowEnd">
          <button class="btn secondary" id="reset">Reset params</button>
          <span class="note">Simulations update automatically when settings change.</span>
        </div>
        <div id="err" class="err" style="margin-top:10px"></div>
      </div>
    </div>

    <!-- Viz -->
    <div class="card">
      <div class="hd">Visualization</div>
      <div class="bd">
        <div class="legend">
          <div class="lg"><span class="dot" style="background:#94a3b8"></span> Reference (experimental)</div>
          <div class="lg"><span class="dot" style="background:#38bdf8"></span> Simulation</div>
        </div>
        <canvas id="plot" width="960" height="360"></canvas>
        <div class="stats">
          <div class="pill">Length: <span id="len">—</span></div>
          <div class="pill">Ref T-range: <span id="trange">—</span></div>
          <div class="pill">RMSE: <span id="rmse">—</span></div>
          <div class="pill">MAE: <span id="mae">—</span></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Load data & library -->
<script src="Phongroop_ref_curves.js"></script>
<script src="meltingLib.js"></script>
<script>
(function(){
  // ---------- Data ----------
  const refData = window.refData || {};
  const entries = Object.entries(refData).map(([id, obj])=>({
    id,
    sequence: Array.isArray(obj.sequence)? (obj.sequence[0]||'') : (obj.sequence||''),
    temps: obj.melting_curve?.temperature || [],
    fracs: obj.melting_curve?.fraction_melted || []
  })).filter(e=> e.sequence && e.temps.length && e.fracs.length);

  // ---------- Elements ----------
  const refSel = document.getElementById('refSelect');
  const seqMeta = document.getElementById('seqMeta');
  const NaEl = document.getElementById('Na');
  const MgEl = document.getElementById('Mg');
  const algoEl = document.getElementById('algo');
  const paramControlsEl = document.getElementById('paramControls');
  const tminEl = document.getElementById('tmin');
  const tmaxEl = document.getElementById('tmax');
  const tstepEl = document.getElementById('tstep');
  const plot = document.getElementById('plot');
  const errEl = document.getElementById('err');
  const lenEl = document.getElementById('len');
  const trangeEl = document.getElementById('trange');
  const rmseEl = document.getElementById('rmse');
  const maeEl = document.getElementById('mae');

  // ---------- Populate dropdowns ----------
  for(const e of entries){
    const opt = document.createElement('option');
    opt.value = e.id; opt.textContent = e.id; refSel.appendChild(opt);
  }
  // Algorithm options (from meltingLib)
  const algoOptions = [
    ['independent','Independent'],
    ['posterior','HMM Posterior'],
    ['viterbi','HMM Viterbi'],
    ['thermo','Thermodynamic (Na⁺/Mg²⁺)'],
    ['hmm','Pedagogical HMM'],
    ['transferFast','Transfer Matrix (Fast)'],
    ['transfer','Transfer Matrix (Full)'],
    ['partitionFast','Partition Function (Fast)'],
    ['partition','Partition Function (Full)'],
    ['polymer','Polymer (Statistical Mechanics)'],
    ['sigmoid','Simple Sigmoid']
  ];
  algoOptions.forEach(([v,lab],i)=>{
    const o=document.createElement('option'); o.value=v; o.textContent=lab; if(i===0) o.selected=true; algoEl.appendChild(o);
  });

  // ---------- State ----------
  let state = {
    ref: null,          // {id, sequence, temps, fracs}
    sim: null,          // {temps, fracs}
    axisTemps: [],      // axis grid based on override
  };
  let runTimer = null;
  const DEFAULT_TEMP_RANGE = { min: 40, max: 100, step: 0.1 };
  const simulationMap = {
    independent: melt.Simulate.simulateIndependent,
    posterior: melt.Simulate.simulateHMMPosterior,
    viterbi: melt.Simulate.simulateHMMViterbi,
    thermo: melt.Simulate.simulateThermodynamic,
    hmm: melt.Simulate.simulateHMM,
    transferFast: melt.Simulate.simulateTransferMatrixFast,
    transfer: melt.Simulate.simulateTransferMatrix,
    partitionFast: melt.Simulate.simulatePartitionFunctionFast,
    partition: melt.Simulate.simulatePartitionFunction,
    polymer: melt.Simulate.simulatePolymer,
    sigmoid: melt.Simulate.simulateSigmoid
  };

  const paramDefaults = {
    window: 15,
    k: 0.8,
    cooperativity: 0.5,
    L: 20,
    piM: 0.5,
    eps: 1e-6,
    conc: 5e-7
  };
  const paramDefs = {
    window: { label: 'Window', min: 5, max: 101, step: 2, default: 15 },
    k: { label: 'Slope k', min: 0.05, max: 5, step: 0.05, default: 0.8 },
    cooperativity: { label: 'Cooperativity', min: 0, max: 5, step: 0.1, default: 0.5 },
    L: { label: 'Domain L', min: 2, max: 200, step: 1, default: 20 },
    piM: { label: 'π<sub>M</sub>', min: 0, max: 1, step: 0.01, default: 0.5 },
    eps: { label: 'ε', min: 1e-7, max: 1e-1, step: 1e-6, default: 1e-6 },
    conc: { label: 'Strand conc (M)', min: 1e-9, max: 1e-3, step: 1e-7, default: 5e-7 }
  };
  const paramSchema = {
    independent: ['window', 'k', 'conc'],
    posterior: ['window', 'k', 'L', 'piM', 'eps', 'conc'],
    viterbi: ['window', 'k', 'L', 'piM', 'eps', 'conc'],
    thermo: ['window', 'k', 'conc'],
    hmm: ['window', 'k', 'L', 'piM', 'eps', 'cooperativity', 'conc'],
    transferFast: ['window', 'cooperativity'],
    transfer: ['cooperativity'],
    partitionFast: ['window', 'cooperativity'],
    partition: ['cooperativity'],
    sigmoid: ['k', 'conc']
  };
  const paramState = { ...paramDefaults };

  function scheduleRun(immediate = false) {
    if (immediate) {
      if (runTimer) clearTimeout(runTimer);
      run();
      return;
    }
    if (runTimer) clearTimeout(runTimer);
    runTimer = setTimeout(run, 60);
  }

  function createParamField(key, def){
    const wrapper = document.createElement('div');
    wrapper.className = 'param-field';
    const label = document.createElement('label');
    label.innerHTML = def?.label || key;
    const input = document.createElement('input');
    input.type = 'number';
    if(def?.step !== undefined) input.step = def.step;
    if(def?.min !== undefined) input.min = def.min;
    if(def?.max !== undefined) input.max = def.max;
    const current = paramState[key] ?? def?.default ?? 0;
    input.value = current;
    const handler = (evt)=>{
      if(input.value === ''){
        if(evt.type === 'change'){
          const fallback = def?.default ?? paramDefaults[key] ?? 0;
          paramState[key] = fallback;
          input.value = fallback;
          scheduleRun();
        }
        return;
      }
      let val = parseFloat(input.value);
      if(!Number.isFinite(val)) return;
      if(typeof def?.min === 'number') val = Math.max(def.min, val);
      if(typeof def?.max === 'number') val = Math.min(def.max, val);
      paramState[key] = val;
      input.value = val;
      scheduleRun();
    };
    input.addEventListener('input', handler);
    input.addEventListener('change', handler);
    wrapper.appendChild(label);
    wrapper.appendChild(input);
    return wrapper;
  }

  function renderParamControls(algo){
    paramControlsEl.innerHTML = '';
    const keys = paramSchema[algo] || [];
    if(!keys.length){
      const msg = document.createElement('div');
      msg.className = 'note';
      msg.style.gridColumn = '1 / -1';
      msg.textContent = 'No adjustable parameters for this algorithm.';
      paramControlsEl.appendChild(msg);
      return;
    }
    keys.forEach(key=>{
      const def = paramDefs[key];
      if(!def) return;
      paramControlsEl.appendChild(createParamField(key, def));
    });
  }

  function resetParamsToDefaults(){
    Object.keys(paramDefaults).forEach(key=> paramState[key] = paramDefaults[key]);
    renderParamControls(algoEl.value);
  }

  // ---------- Helpers ----------
  function initRef(id){
    const e = entries.find(x=>x.id===id) || entries[0];
    state.ref = e;
    const minT = Math.min(...e.temps), maxT = Math.max(...e.temps);
    if(!tminEl.value) tminEl.value = DEFAULT_TEMP_RANGE.min.toFixed(1);
    if(!tmaxEl.value) tmaxEl.value = DEFAULT_TEMP_RANGE.max.toFixed(1);
    lenEl.textContent = e.sequence.length;
    trangeEl.textContent = `${minT.toFixed(1)}–${maxT.toFixed(1)} °C`;
    seqMeta.textContent = `${e.id} • ${e.sequence.length} nt`;
    rebuildAxis();
    draw();
  }

  function rebuildAxis(){
    const refTemps = state.ref?.temps || [];
    const refMin = refTemps.length ? Math.min(...refTemps) : DEFAULT_TEMP_RANGE.min;
    const refMax = refTemps.length ? Math.max(...refTemps) : DEFAULT_TEMP_RANGE.max;
    const tmin = safeNum(tminEl.value, refMin, DEFAULT_TEMP_RANGE.min);
    let tmax = safeNum(tmaxEl.value, refMax, DEFAULT_TEMP_RANGE.max);
    const stepInput = safeNum(tstepEl.value, DEFAULT_TEMP_RANGE.step, DEFAULT_TEMP_RANGE.step);
    const step = Math.max(0.01, stepInput);
    if (tmax <= tmin) tmax = tmin + step;
    const n = Math.max(2, Math.floor((tmax - tmin)/step) + 1);
    state.axisTemps = Array.from({length:n}, (_,i)=> tmin + i*step);
  }

  function safeNum(v, fallback, hardDefault){
    const defaultVal = Number.isFinite(fallback) ? fallback : hardDefault;
    const x = parseFloat(v);
    return Number.isFinite(x) ? x : defaultVal;
  }

  function interpToGrid(srcX, srcY, tgtX){
    if(!srcX.length || !tgtX.length) return [];
    const out=[]; let j=0;
    for(const x of tgtX){
      while(j < srcX.length-1 && srcX[j+1] < x) j++;
      if(x <= srcX[0]) out.push(srcY[0]);
      else if(x >= srcX[srcX.length-1]) out.push(srcY[srcY.length-1]);
      else {
        const x0=srcX[j], x1=srcX[j+1], y0=srcY[j], y1=srcY[j+1];
        const t=(x-x0)/(x1-x0); out.push(y0 + t*(y1-y0));
      }
    }
    return out;
  }

  function computeMetrics(ref, sim){
    const n = Math.min(ref.length, sim.length);
    if(!n) return {rmse:NaN, mae:NaN};
    let se=0, ae=0, m=0;
    for(let i=0;i<n;i++){
      const r=ref[i], s=sim[i];
      if(Number.isFinite(r) && Number.isFinite(s)){
        const d=r-s; se+=d*d; ae+=Math.abs(d); m++;
      }
    }
    return {rmse: m? Math.sqrt(se/m):NaN, mae: m? ae/m:NaN};
  }

  // ---------- Drawing ----------
  function draw(){
    const ctx = plot.getContext('2d');
    const W=plot.width, H=plot.height;
    ctx.clearRect(0,0,W,H);

    const left=48, right=W-16, top=16, bot=H-34;
    ctx.strokeStyle='rgba(255,255,255,.2)';
    ctx.strokeRect(left, top, right-left, bot-top);

    const temps = state.axisTemps.length ? state.axisTemps : (state.ref?.temps || []);
    if(!temps.length) return;
    const Tmin = Math.min(...temps), Tmax = Math.max(...temps);
    const xs = T=> left + (right-left) * ((T - Tmin) / (Tmax - Tmin));
    const ys = y=> bot - (bot-top) * y; // y in [0,1]

    // X ticks & labels
    ctx.fillStyle='#9ca3af'; ctx.font='12px ui-sans-serif'; ctx.textAlign='center';
    for(let i=0;i<=5;i++){
      const T = Tmin + (i/5)*(Tmax-Tmin); const x = xs(T);
      ctx.fillText(T.toFixed(1), x, H-12);
      ctx.beginPath(); ctx.moveTo(x, bot); ctx.lineTo(x, bot+4); ctx.stroke();
    }
    // Y ticks 0..1
    ctx.textAlign='right';
    for(let i=0;i<=5;i++){
      const yv = i/5; const y = ys(yv);
      ctx.fillText(yv.toFixed(1), left-6, y+4);
      ctx.beginPath(); ctx.moveTo(left-4, y); ctx.lineTo(left, y); ctx.stroke();
    }

    // Reference curve (sampled to axis grid for smoothness)
    if(state.ref){
      const rY = interpToGrid(state.ref.temps, state.ref.fracs, temps);
      ctx.strokeStyle = '#94a3b8'; ctx.lineWidth=2; ctx.beginPath();
      for(let i=0;i<temps.length;i++){
        const x=xs(temps[i]), y=ys(rY[i]);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      // reference points at original positions
      ctx.fillStyle='#cbd5e1';
      for(let i=0;i<state.ref.temps.length;i++){
        const x=xs(state.ref.temps[i]), y=ys(state.ref.fracs[i]);
        ctx.beginPath(); ctx.arc(x,y,2.3,0,Math.PI*2); ctx.fill();
      }
    }

    // Simulated curve
    if(state.sim?.temps?.length){
      const sT = state.sim.temps, sY = state.sim.fracs;
      ctx.strokeStyle = '#38bdf8'; ctx.lineWidth=2.2; ctx.beginPath();
      for(let i=0;i<sT.length;i++){
        const x=xs(sT[i]), y=ys(sY[i]);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

  }

  // ---------- Simulation ----------
  function run(){
    if (runTimer) {
      clearTimeout(runTimer);
      runTimer = null;
    }
    try{
      errEl.style.display='none';
      if(!state.ref) throw new Error('No reference selected.');

      rebuildAxis();
      const temps = state.axisTemps.slice();
      if (!temps.length) {
        state.sim = { temps: [], fracs: [] };
        draw();
        return;
      }

      // conditions: UI values are molar; pass through directly
      const Na = safeNum(NaEl.value, 0.05, 0.05);
      const Mg = safeNum(MgEl.value, 0.001, 0.001);
      const conditions = { Na, Mg };

      const params = { ...paramState };

      const algo = algoEl.value;
      const seq = state.ref.sequence;
      const handler = simulationMap[algo] || simulationMap.independent;
      const sim = handler({ sequence: seq, temperatures: temps, conditions, params, options: {} }) || {};

      state.sim = {
        temps: sim.temperatures || temps,
        fracs: sim.fractionMelted || new Array(temps.length).fill(NaN)
      };

      // compute metrics on the axis grid
      const refOnAxis = interpToGrid(state.ref.temps, state.ref.fracs, state.axisTemps);
      const {rmse, mae} = computeMetrics(refOnAxis, state.sim.fracs);
      rmseEl.textContent = Number.isFinite(rmse)? rmse.toFixed(4) : '—';
      maeEl.textContent = Number.isFinite(mae)? mae.toFixed(4) : '—';

      draw();
    }catch(err){
      console.error(err);
      errEl.textContent = err.message || String(err);
      errEl.style.display='block';
    }
  }

  // ---------- Interactions ----------

  document.getElementById('reset').addEventListener('click', ()=>{
    NaEl.value=0.05; MgEl.value=0.001;
    resetParamsToDefaults();
    tminEl.value = DEFAULT_TEMP_RANGE.min.toFixed(1);
    tmaxEl.value = DEFAULT_TEMP_RANGE.max.toFixed(1);
    tstepEl.value = DEFAULT_TEMP_RANGE.step;
    scheduleRun(true);
  });

  // live updates for axis controls
  [tminEl,tmaxEl,tstepEl].forEach(el=>{
    const handler = ()=> scheduleRun();
    el.addEventListener('input', handler);
    el.addEventListener('change', handler);
  });

  const conditionInputs = [NaEl, MgEl];
  conditionInputs.forEach(el=>{
    const handler = ()=> scheduleRun();
    el.addEventListener('input', handler);
    el.addEventListener('change', handler);
  });

  refSel.addEventListener('change', ()=>{
    initRef(refSel.value);
    scheduleRun(true);
  });

  algoEl.addEventListener('change', ()=>{
    renderParamControls(algoEl.value);
    scheduleRun();
  });

  renderParamControls(algoEl.value);

  // ---------- Init ----------
  if(entries.length){
    initRef(entries[0].id);
    refSel.value = entries[0].id;
    scheduleRun(true);
  } else {
    document.getElementById('err').textContent = 'No valid reference entries found in data file.';
    document.getElementById('err').style.display = 'block';
  }
})();
</script>
</body>
</html>
